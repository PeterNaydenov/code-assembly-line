/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var CodeAssemblyLine;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/***/ ((module) => {

"use strict";
eval(" // * Error Messages\n\nconst msg = {\n  'notDefined': 'Not defined error.' // Template errors\n  ,\n  'brokenTemplate': 'Broken string template. Placeholder with missing closing tag.',\n  'wrongDataTemplate': 'Broken data template. Object is not according the standards.',\n  'overwriteTemplate': 'Error: Overwrite of existing template is not permited by configuration.',\n  'missingTemplate': `Error: Template \"%s\" doesn't exist.` // Process errors\n  ,\n  'wrongExtProcess': 'Wrong process data. Should be an array of \"processSteps\".',\n  'emptyExtProcess': 'Empty process! Process should contain steps(processSteps)',\n  'brokenProcess': 'Broken process description.',\n  'missingOperation': 'Process has step with missing operation. Set parameter \"do\".',\n  'overwriteProcess': 'Error: Process with name \"%s\" is already defined.',\n  'notaValidOperation': `Error: \"%s\" is not a valid operation`,\n  'blockExpectString': `Block expects string data. %s`,\n  'dataExpectObject': `Data operations require objects. %s` // Data errors\n  ,\n  'overwriteData': 'Error: Data with name \"%s\" is already defined.' // Validation errors\n  ,\n  'processNotExists': 'Error: Process \"%s\" does not exist.',\n  'templateNotExists': 'Error: Template \"%s\" is not available',\n  'invalidStorageName': 'Error: Process-step \"save\" has param \"as: %s\". Param \"as\" should be \"data\", \"template\" or \"process\". ',\n  'invalidJSON': 'Error: Invalid JSON format was provided for saving in \"processes\": %s'\n};\n\nconst showError = function (msgName, vars) {\n  let result = msg[msgName] || msg['notDefined'];\n\n  if (vars) {\n    if (!(vars instanceof Array)) vars = [vars];\n    vars.forEach(v => result = result.replace('%s', v));\n  }\n\n  return result;\n}; // msg func.\n\n\nmodule.exports = showError;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/errors.js?");

/***/ }),

/***/ "./src/general-tools.js":
/*!******************************!*\
  !*** ./src/general-tools.js ***!
  \******************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst tools = {\n  renameTemplate: function (extLib, mod) {\n    //   (externalTemplate, mod{}) -> externalTemplate\n    // * Change-name tool for externalTemplate object\n    // mod - { existingTemplateName: newTemplateName }\n    const updateKeys = Object.keys(mod),\n          existingKeys = Object.keys(extLib);\n    return existingKeys.reduce((res, key) => {\n      if (updateKeys.includes(key)) res[mod[key]] = extLib[key];else res[key] = extLib[key];\n      return res;\n    }, {});\n  } // modifyTemplate func.\n\n}; // tools\n\nmodule.exports = tools;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/general-tools.js?");

/***/ }),

/***/ "./src/help.js":
/*!*********************!*\
  !*** ./src/help.js ***!
  \*********************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction getHelpLib({\n  showError\n}) {\n  const help = {\n    _validateProcess(engine, processName) {\n      // * Validate process before run. Find if process exists and all templates needed are available.\n      let errors = [];\n      const processExists = engine.processes.hasOwnProperty(processName),\n            intProcess = engine.processes[processName];\n      if (processExists && intProcess['errors']) errors = errors.concat(intProcess['errors']);\n      if (!processExists) errors.push(showError('processNotExists', processName));else {\n        intProcess['arguments'].reduce((listTemplates, step) => {\n          if (step.do == 'draw' && step.tpl) listTemplates.push(step.tpl);\n          return listTemplates;\n        }, []).forEach(name => {\n          const tpl = engine.templates[name];\n          if (tpl && tpl['errors']) errors = errors.concat(tpl['errors']);\n          if (!tpl) errors.push(showError('templateNotExists', name));\n        });\n      }\n      return errors;\n    } // _validateProcess func.\n    ,\n\n    _extractLib(tpl, libRequst) {\n      //   (tpl:inTemplates[], libRequest:string[]) -> ExternalTemplate\n      // * Creates new ExternalTemplate by removing libName from template name \n      const tplNames = Object.keys(tpl).filter(name => name.includes('/'));\n      let result = {};\n      if (libRequst) result = libRequst.reduce((res, libItem) => {\n        tplNames.filter(name => name.indexOf(libItem) == 0).forEach(name => {\n          const sliceIndex = name.indexOf('/'),\n                prop = name.slice(sliceIndex + 1);\n          res[prop] = tpl[name].tpl.join('');\n        });\n        return res;\n      }, {});else {\n        const allNames = Object.keys(tpl);\n        allNames.forEach(name => result[name] = tpl[name].tpl.join(''));\n      }\n      return result;\n    } // _extractLib func.\n    ,\n\n    _flatten(data, objects = [], buffer = {}) {\n      let result = Object.assign({}, buffer),\n          keyIn = false;\n\n      if (!data) {\n        const [k, val] = objects.pop();\n        keyIn = k;\n        data = val;\n      }\n\n      for (let key in data) {\n        const value = data[key];\n        let newKey = key;\n        if (keyIn) newKey = `${keyIn}/${key}`;\n        if (typeof value == 'function') continue; //   Data can't contain functions. Ignore them\n\n        if (help._isPrimitive(value)) result[newKey] = value;else objects.push([newKey, value]);\n      }\n\n      if (objects.length != 0) return help._flatten(false, objects, result);\n      return result;\n    } // _flatten func.\n    ,\n\n    _isPrimitive(value) {\n      return typeof value === 'object' ? false : true;\n    } // isPrimitive func.\n\n\n  }; // help lib\n\n  return help;\n} // getHelpLib func.\n\n\nmodule.exports = getHelpLib;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/help.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* \n   Code Assembly Line\n   ==================\n\n    History notes:\n     - Project was started on September 23th, 2017.\n     - Published on GitHub for first time: November 16th, 2017\n     - Version 2.0. January 9th, 2018\n     - Version 3.0. May 6th, 2019\n*/\n\nconst showError = __webpack_require__(/*! ./errors */ \"./src/errors.js\"),\n      chop = __webpack_require__(/*! ./template-chop */ \"./src/template-chop.js\"),\n      tools = __webpack_require__(/*! ./general-tools */ \"./src/general-tools.js\"),\n      templateTools = __webpack_require__(/*! ./template-tools */ \"./src/template-tools.js\")({\n  chop,\n  showError\n}),\n      help = __webpack_require__(/*! ./help */ \"./src/help.js\")({\n  showError\n}),\n      operation = __webpack_require__(/*! ./process-operations */ \"./src/process-operations.js\")({\n  help\n}),\n      processTools = __webpack_require__(/*! ./process-tools */ \"./src/process-tools.js\")({\n  help,\n  showError,\n  operation\n}),\n      lib_Template = __webpack_require__(/*! ./lib-template */ \"./src/lib-template.js\")({\n  help,\n  showError,\n  templateTools\n}),\n      lib_Data = __webpack_require__(/*! ./lib-data */ \"./src/lib-data.js\")({\n  help,\n  showError\n}),\n      lib_Process = __webpack_require__(/*! ./lib-process */ \"./src/lib-process.js\")({\n  help,\n  showError,\n  processTools\n}); // Default config object applied to every codeAssembly object.\n\n\nconst codeAssemblyConfig = {\n  htmlAttributes: ['id', 'name', 'href', 'src', 'value', 'data', 'alt', 'role', 'class']\n}; // config\n\nfunction codeAssembly(cfg) {\n  this.templates = {};\n  this.processes = {};\n  this.data = {};\n  this.config = {};\n  Object.keys(codeAssemblyConfig).forEach(k => this.config[k] = codeAssemblyConfig[k]);\n  if (cfg) Object.keys(cfg).forEach(k => this.config[k] = cfg[k]);\n} // codeAssembly func.\n// * Code-Assembly-Line API\n\n\ncodeAssembly.prototype = {\n  tools: tools // Usefull template and process related functions (external)\n  // Template I/O Operations\n  ,\n  insertTemplate: lib_Template.insert // Insert templates;\n  ,\n  insertTemplateLib: lib_Template.insertLib // Insert templates as a template-library;    \n  ,\n  getTemplate: lib_Template.get // Export templates;\n  ,\n  getTemplateLib: lib_Template.getLib // Export templates from template-library;\n  ,\n  getPlaceholders: lib_Template.getPlaceholders // Return placeholders per template;\n  // Template Manipulation\n  ,\n  renameTemplate: lib_Template.rename // Change name of template/templates;\n  ,\n  removeTemplate: lib_Template.remove // Remove template/templates;\n  // Processes\n  ,\n  insertProcess: lib_Process.insert // Insert new process;\n  ,\n  insertProcessLib: lib_Process.insertLib // Insert list of processes with a single operation;\n  ,\n  mixProcess: lib_Process.mix // Set new process as combination of existing processes;\n  ,\n  getProcessLib: lib_Process.getLib // Export processes from process-library;\n  ,\n  getHooks: lib_Process.getHooks // Provide information about hooks available;\n  ,\n  run: lib_Process.run // Execute process/processes;\n  // Process Manipulation\n  ,\n  renameProcess: lib_Process.rename // Renames a process\n  ,\n  removeProcess: lib_Process.remove // Remove process/processes\n  // Data I/O\n  ,\n  insertData: lib_Data.insert // Insert data. Save data. Word 'blocks'\n  ,\n  insertDataLib: lib_Data.insertLib // Insert set of data\n  ,\n  getBlock: lib_Data.getBlock // Obtain rendered code snippets \n  ,\n  getBlocks: lib_Data.getBlock // Data Manipulation\n  ,\n  renameData: lib_Data.rename // Change name of data record\n  ,\n  removeData: lib_Data.remove // Remove data record from template engine\n\n}; // codeAssembly prototype\n\nmodule.exports = codeAssembly;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/index.js?");

/***/ }),

/***/ "./src/lib-data.js":
/*!*************************!*\
  !*** ./src/lib-data.js ***!
  \*************************/
/***/ ((module) => {

eval("function getLibData({\n  help,\n  showError\n}) {\n  const lib_Data = {\n    insert(data, method = 'add') {\n      //   ({},enum) -> engine\n      const me = this,\n            flatData = help._flatten(data),\n            dataKeys = Object.keys(flatData);\n\n      dataKeys.forEach(name => {\n        const hasField = me.data[name] ? true : false;\n        if (hasField && method == 'add') return;\n        if (!hasField && method == 'update') return;\n\n        if (hasField && method == 'heap') {\n          me.data[name] += ' ' + flatData[name];\n          return;\n        }\n\n        me.data[name] = flatData[name];\n      });\n      return me;\n    } //   insert func.   -- Data\n    ,\n\n    insertLib(data, libName, method = 'add') {\n      //   ({}, string) -> engine\n      const me = this,\n            flatData = help._flatten(data),\n            dataKeys = Object.keys(flatData);\n\n      dataKeys.forEach(name => {\n        const newKey = `${libName}/${name}`,\n              hasField = me.data[newKey];\n        if (hasField && method == 'add') return;\n        if (!hasField && method == 'update') return;\n\n        if (hasField && method == 'heap') {\n          me.data[newKey] += ' ' + flatData[name];\n          return;\n        }\n\n        me.data[newKey] = flatData[name];\n      });\n      return me;\n    } // insertLib func.   -- Data\n    ,\n\n    rename(ops) {\n      //   ({oldName:newName}) -> engine\n      // * Change data-record names\n      const me = this,\n            list = Object.keys(ops),\n            doOverwrite = me.config.overwriteData;\n      list.forEach(key => {\n        if (!me.data[key]) return;\n        const newKey = ops[key],\n              keyAlreadyDefined = me.data[newKey] ? true : false;\n\n        if (keyAlreadyDefined && !doOverwrite) {\n          console.error(showError('overwriteData', newKey));\n          return;\n        } else {\n          me.data[newKey] = me.data[key];\n          delete me.data[key];\n        }\n      });\n      return me;\n    } // rename func   --- Data\n    ,\n\n    remove(dataName) {\n      //   ( dataName:string|string[]) -> engine\n      const me = this;\n      let listDelete;\n      if (dataName instanceof Array) listDelete = dataName;else {\n        const t = Object.keys(arguments);\n        listDelete = t.map(k => arguments[k]);\n      }\n      listDelete.forEach(item => delete me.data[item]);\n      return me;\n    } //   remove func.   -- Data\n    ,\n\n    getBlock(blockName) {\n      //   ( string ) -> string\n      const me = this;\n      let blockRequst = [];\n      if (blockName instanceof Array) blockRequst = blockName;else {\n        const t = Object.keys(arguments);\n        blockRequst = t.map(k => arguments[k]);\n      }\n      return blockRequst.reduce((res, name) => {\n        const snippet = me.data[`block/${name}`] ? me.data[`block/${name}`] : '';\n        res += snippet;\n        return res;\n      }, '');\n    } // getBlock func.   -- Data\n\n\n  }; // lib_Data\n\n  return lib_Data;\n} // getLibData func.\n\n\nmodule.exports = getLibData;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/lib-data.js?");

/***/ }),

/***/ "./src/lib-process.js":
/*!****************************!*\
  !*** ./src/lib-process.js ***!
  \****************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction getLibProcess({\n  help,\n  showError,\n  processTools\n}) {\n  const lib_Process = {\n    insert(ext, name, method = 'add') {\n      // (ext: extProcess, name: string) -> engine\n      const me = this,\n            wasRegistered = me.processes[name] || false;\n\n      switch (method) {\n        case 'add':\n          if (wasRegistered) {\n            console.error(showError('overwriteProcess', name));\n            return;\n          }\n\n          break;\n\n        case 'update':\n          if (!wasRegistered) {\n            console.error(`Can not update process \"${name}\". It is still not defined.`);\n            return;\n          }\n\n          break;\n      }\n\n      me.processes[name] = processTools.interpret(ext);\n      return me;\n    } //   insert func.   -- Process\n    ,\n\n    insertLib(extLib, libName) {\n      // ( extProcessLib, string ) -> engine\n      const processNames = Object.keys(extLib);\n      processNames.forEach(extName => {\n        const name = libName ? `${libName}/${extName}` : extName;\n        let actionSteps;\n\n        if (extLib[extName] instanceof Array) {\n          actionSteps = [].concat(extLib[extName]);\n          lib_Process.insert.call(this, actionSteps, name);\n        }\n      });\n      return this;\n    } //   insertLib func.  -- Process\n    ,\n\n    mix(mixList, newProcessName, method = 'add') {\n      //   ( mixList:string[], processName:string ) -> engine\n      // * Set new process as combination of existing processes\n      const me = this,\n            processes = me.processes,\n            wasRegistered = me.processes[newProcessName] || false;\n      let mix = {}; // new process container\n\n      switch (method) {\n        case 'add':\n          if (wasRegistered) {\n            console.error(showError('overwriteProcess', newProcessName));\n            return me;\n          }\n\n          break;\n\n        case 'update':\n          if (!wasRegistered) {\n            console.error(showError('overwriteProcess', newProcessName));\n            return me;\n          }\n\n          break;\n      }\n\n      mix.steps = [];\n      mix.arguments = [];\n      mix.hooks = [];\n      mixList.forEach(requestedName => {\n        if (!processes[requestedName]) return;\n        const source = processes[requestedName],\n              hookNames = source.hooks.map(name => `${requestedName}/${name}`),\n              newArguments = source.arguments.map(arg => {\n          if (arg.do != 'hook') return arg;\n          return {\n            do: 'hook',\n            name: `${requestedName}/${arg.name}`\n          };\n        });\n        mix['steps'] = mix['steps'].concat(source['steps']);\n        mix['arguments'] = mix['arguments'].concat(newArguments);\n        mix['hooks'] = mix['hooks'].concat(hookNames);\n      });\n      me.processes[newProcessName] = mix;\n      return me;\n    } //   mix func.   -- Process\n    ,\n\n    getLib(name) {\n      // * Extract process library\n      const me = this,\n            allKeys = Object.keys(me.processes),\n            takeEverything = name ? false : true;\n      const result = allKeys.reduce((res, key) => {\n        if (!takeEverything) {\n          if (key.includes(name)) {\n            const t = key.split('/');\n            t.shift();\n            const newKey = t.join('/');\n            res[newKey] = me.processes[key]['arguments'];\n          }\n        } else res[key] = me.processes[key]['arguments'];\n\n        return res;\n      }, {});\n      return result;\n    } // getLib func.   -- Process\n    ,\n\n    rename(ops) {\n      //   ({oldName:newName}) -> engine\n      // * Change process names\n      const me = this,\n            list = Object.keys(ops),\n            doOverwrite = me.config.overwriteProcesses;\n      list.forEach(key => {\n        if (!me.processes[key]) return;\n        const newKey = ops[key],\n              keyAlreadyDefined = me.processes[newKey] ? true : false;\n\n        if (keyAlreadyDefined && !doOverwrite) {\n          console.error(showError('overwriteProcess', newKey));\n          return;\n        } else {\n          me.processes[newKey] = me.processes[key];\n          delete me.processes[key];\n        }\n      });\n      return me;\n    } // rename func.   -- Process\n    ,\n\n    remove(processName) {\n      //   ( processName:string|string[]) -> engine\n      const me = this;\n      let listDelete;\n      if (processName instanceof Array) listDelete = processName;else {\n        const t = Object.keys(arguments);\n        listDelete = t.map(k => arguments[k]);\n      }\n      listDelete.forEach(item => delete me.processes[item]);\n      return me;\n    } // remove func.   -- Process\n    ,\n\n    getHooks(processName) {\n      //   (processName) -> { hookName : undefined }\n      // *** Returns an object with all hook names defined in the process.\n      const recordExists = this.processes.hasOwnProperty(processName);\n\n      if (recordExists) {\n        const hooks = this.processes[processName].hooks;\n        return hooks.reduce((res, name) => {\n          res[name] = undefined;\n          return res;\n        }, {});\n      } else return {};\n    } //   getHooks func.   -- Process\n    ,\n\n    run(processList, data, hooks) {\n      if (!(processList instanceof Array)) processList = [processList];\n      let internalData,\n          error = processList.reduce((res, processName) => {\n        const errorUpdate = help._validateProcess(this, processName);\n\n        return res.concat(errorUpdate);\n      }, []);\n      if (data == null) internalData = [{}];else if (!(data instanceof Array)) internalData = [data];else internalData = data;\n\n      if (error.length == 0) {\n        let current = internalData;\n        processList.forEach(processName => {\n          current = processTools.run.call(this, this.processes[processName], current, hooks);\n        });\n        return current;\n      } else {\n        console.error(error);\n        return error;\n      }\n    } //   run func.   -- Process\n\n\n  }; // lib_Process lib\n\n  return lib_Process;\n} // getLibProcess func.\n\n\nmodule.exports = getLibProcess;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/lib-process.js?");

/***/ }),

/***/ "./src/lib-template.js":
/*!*****************************!*\
  !*** ./src/lib-template.js ***!
  \*****************************/
/***/ ((module) => {

eval("function getLibTemplate({\n  help,\n  templateTools,\n  showError\n}) {\n  const str2intTemplate = templateTools.str2intTemplate,\n        interpretTemplate = templateTools.load_interpretTemplate(str2intTemplate);\n  const lib_Template = {\n    insert(extTemplate, method = 'add') {\n      // (ExternalTemplate,saveMethod) -> engine\n\n      /**\n       *  saveMethod: enum. Values: add | update | heap | overwrite\n       */\n      let me = this,\n          templateNames = Object.keys(extTemplate);\n      templateNames.forEach(name => {\n        const hasField = me.templates[name] != null ? true : false;\n        if (hasField && method == 'add') return;\n        if (!hasField && method == 'update') return;\n\n        if (hasField && method == 'heap') {\n          let existingTpl = me.templates[name].tpl.join(''),\n              newTemplate = existingTpl + ' ' + extTemplate[name];\n          me.templates[name] = interpretTemplate(newTemplate);\n          return;\n        }\n\n        me.templates[name] = interpretTemplate(extTemplate[name]);\n      });\n      return me;\n    } //   insert func.   -- Template\n    ,\n\n    insertLib(extLib, libName, method = 'add') {\n      //   ( ExternalTemplate,  string ) -> engine\n      let me = this,\n          simpleTemplates = Object.keys(extLib);\n      simpleTemplates.forEach(extName => {\n        const newTpl = {},\n              name = `${libName}/${extName}`;\n        newTpl[name] = extLib[extName];\n        lib_Template.insert.call(me, newTpl, method);\n      });\n      return me;\n    } //   insertLib func.  -- Template\n    ,\n\n    rename(ops) {\n      //   ({oldName:newName}) -> engine\n      // * Change template names\n      const me = this,\n            list = Object.keys(ops),\n            doOverwrite = me.config.overwriteTemplates;\n      list.forEach(key => {\n        if (!me.templates[key]) return;\n        const newKey = ops[key],\n              keyExists = me.templates[newKey] ? true : false;\n\n        if (keyExists && !doOverwrite) {\n          console.error(showError('overwriteTemplate'));\n          return;\n        } else {\n          me.templates[newKey] = me.templates[key];\n          delete me.templates[key];\n        }\n      });\n      return me;\n    } //   rename func.   -- Template\n    ,\n\n    remove(tplName) {\n      //   ( tplName:string|string[]) -> engine\n      const me = this;\n      let listDelete;\n      if (tplName instanceof Array) listDelete = tplName;else {\n        const t = Object.keys(arguments);\n        listDelete = t.map(k => arguments[k]);\n      }\n      listDelete.forEach(item => delete me.templates[item]);\n      return me;\n    } //   remove func.   -- Template\n    ,\n\n    get(tplName) {\n      // (tplName: string|string[]) -> ExternalTemplate\n      const me = this,\n            tpl = me.templates;\n      let tplRequst;\n      if (tplName instanceof Array) tplRequst = tplName;else {\n        const t = Object.keys(arguments);\n        tplRequst = t.map(k => arguments[k]);\n      }\n      return tplRequst.reduce((res, item) => {\n        if (tpl[item]) res[item] = tpl[item].tpl.join('');else res[item] = '';\n        return res;\n      }, {});\n    } //   get func.   -- Template\n    ,\n\n    getLib(libName) {\n      //   (libName:string|string[]|undefind) -> ExternalTemplate\n      const me = this,\n            takeEverything = libName ? false : true;\n      let libRequst;\n      if (libName == null) libRequst = null;else if (libName instanceof Array) libRequst = libName;else {\n        const t = Object.keys(arguments);\n        libRequst = t.map(k => arguments[k]);\n      }\n      return help._extractLib(me.templates, libRequst);\n    } // getLib func.   -- Template\n    ,\n\n    getPlaceholders(templateName) {\n      //   (templateName:string) -> placeholderNames:string[].\n      const tpl = this.templates[templateName];\n      if (tpl) return Object.keys(tpl.placeholders);else return [];\n    } // getPlaceholders func.   -- Template\n\n\n  }; //   lib_Template lib\n\n  return lib_Template;\n} // getLibTemplate func.\n\n\nmodule.exports = getLibTemplate;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/lib-template.js?");

/***/ }),

/***/ "./src/process-operations.js":
/*!***********************************!*\
  !*** ./src/process-operations.js ***!
  \***********************************/
/***/ ((module) => {

"use strict";
eval("\n/*\n   Operations: \n         - draw\n         - alterTemplate\n         - block\n         - set\n         - alter\n         - add \n         - copy\n         - remove\n         - hook\n         - load // load is not part of the library but is valid op. Find it in process-tools\n*/\n\nfunction getProcessOperations({\n  help\n}) {\n  const lib = {\n    draw(params) {\n      // ( {params} ) -> string[]\n      // * Render template.\n\n      /*\n          Params:\n             template:{intTemplate}. Selected template for this draw operation;\n             data:{any}[]. Current data;\n             sharedData:{any}. Engine data object;\n             htmlAttributes: string[]. Render '_attr' will consider this list of items and their order;\n             missField?:string. Strategy for fulfill missing data-fields;\n             missData?:string.  Strategy for substitute data-record on missing data-fields;\n             hookFn: (placeholderName:string) -> renderResult:string. Result will be added to render result array;\n           MissField argument could be a string but also has two predefined options:\n            '_position': will render placeholder name;\n            '_hide'    : will not render anything;\n            '_fn'      : hook function will take care about missing fields;\n          \n          MissData argument could be a string or some of predefined options:\n           '_hide': will not render anything from this data-record\n           '_fn'  : hook function will take care about the record;\n          \n      */\n      let {\n        template,\n        data,\n        sharedData,\n        htmlAttributes,\n        missField,\n        missData,\n        hookFn\n      } = params,\n          result = [];\n      data.forEach((obj, _count) => {\n        const current = help._flatten(obj),\n              keys = Object.keys(current);\n\n        let tpl = lib._copyList(template.tpl),\n            places = Object.assign({}, template.placeholders),\n            spaces = template.spaces // enumerable: 1-space before, 2-space after, 3-space before and after\n        ,\n            spaceBefore = '',\n            spaceAfter = '';\n\n        if (places['_attr']) {\n          // calculate html attributes only if '_attr' placeholder exists in template\n          const attrTarget = places['_attr'][0];\n          spaceBefore = spaces['_attr'] && spaces['_attr'] % 2 ? ' ' : '';\n          spaceAfter = spaces['_attr'] && spaces['_attr'] > 1 ? ' ' : '';\n\n          const attr = lib._createAttributes(current, htmlAttributes).trim();\n\n          if (attr) tpl[attrTarget] = `${spaceBefore}${attr}${spaceAfter}`; // generate attributes string\n          else tpl[attrTarget] = '';\n          delete places['_attr'];\n        }\n\n        if (places['_count']) {\n          // replace _count if  '_count' placeholder exists in template\n          const countTarget = places['_count'];\n          spaceBefore = spaces['_count'] && spaces['_count'] % 2 ? ' ' : '';\n          spaceAfter = spaces['_count'] && spaces['_count'] > 1 ? ' ' : '';\n          countTarget.forEach(position => tpl[position] = `${spaceBefore}${_count + 1}${spaceAfter}`);\n          delete places['_count'];\n        }\n\n        keys.forEach(k => {\n          const positions = places[k];\n          spaceBefore = spaces[k] && spaces[k] % 2 ? ' ' : '';\n          spaceAfter = spaces[k] && spaces[k] > 1 ? ' ' : '';\n\n          if (positions) {\n            for (let position of positions) tpl[position] = `${spaceBefore}${current[k]}${spaceAfter}`;\n\n            delete places[k];\n          }\n        });\n        let neglected = Object.keys(places),\n            someNeglected = neglected.length > 0;\n\n        if (someNeglected && sharedData) {\n          // find values in sharedData\n          for (let placeholder of neglected) {\n            if (sharedData[placeholder]) {\n              const list = places[placeholder];\n              spaceBefore = spaces[placeholder] && spaces[placeholder] % 2 ? ' ' : '';\n              spaceAfter = spaces[placeholder] && spaces[placeholder] > 1 ? ' ' : '';\n              list.forEach(id => tpl[id] = `${spaceBefore}${sharedData[placeholder]}${spaceAfter}`);\n              delete places[placeholder];\n            }\n          }\n        } // if someNeglected\n\n\n        neglected = Object.keys(places);\n        someNeglected = neglected.length > 0;\n\n        if (someNeglected && missField) {\n          // miss field strategy\n          let missFieldUpdate;\n          if (missField == '_fn' && typeof hookFn != 'function') missField = '_hide';\n\n          switch (missField) {\n            case '_fn':\n              missFieldUpdate = hookFn;\n              break;\n\n            case '_hide':\n              missFieldUpdate = () => '';\n\n              break;\n\n            case '_position':\n              missFieldUpdate = pos => pos;\n\n              break;\n\n            default:\n              missFieldUpdate = () => missField;\n\n          } // switch missField\n\n\n          for (let position of neglected) {\n            const list = places[position];\n            list.forEach(el => tpl[el] = missFieldUpdate(position));\n          }\n        } // if missField\n\n\n        if (someNeglected && missData) {\n          // miss data strategy\n          let missDataUpdate;\n          if (missData == '_fn' && typeof hookFn != 'function') missData = '_hide';\n\n          switch (missData) {\n            case '_fn':\n              missDataUpdate = x => [hookFn(x)];\n\n              break;\n\n            case '_hide':\n              missDataUpdate = () => [];\n\n              break;\n\n            default:\n              missDataUpdate = () => [missData];\n\n          } // switch missData                            \n\n\n          tpl = missDataUpdate(neglected);\n        } // if missData\n\n\n        if (tpl.length > 0) result.push(tpl.join(''));\n      });\n      return result;\n    } // draw func.\n    ,\n\n    _createAttributes(data, attributes) {\n      //   ({}, string[]) -> string\n      // *** 'attr' placeholder calculation\n      const attr = {},\n            dataAttr = new RegExp('^data-');\n      let dataItems = '';\n\n      for (let item in data) {\n        if (item === 'name') continue; //   Ignore 'name'\n\n        if (item === 'id') {\n          attr['id'] = `id=\"${data[item]}\"`;\n          attr['name'] = `name=\"${data[item]}\"`;\n          continue;\n        }\n\n        if (item === 'className') {\n          attr['class'] = `class=\"${data[item]}\"`;\n          continue;\n        }\n\n        if (attributes.includes(item)) {\n          attr[item] = `${item}=\"${data[item]}\"`;\n          continue;\n        }\n\n        if (dataAttr.test(item)) {\n          attr[item] = `${item}=\"${data[item]}\"`;\n          dataItems += ` ${attr[item]}`;\n        }\n      }\n\n      return attributes.reduce((res, item) => {\n        if (attr[item]) res += ` ${attr[item]}`;\n        if (item == 'data') res += ` ${dataItems}`;\n        return res;\n      }, '');\n    } // _createAttributes func.\n    ,\n\n    _copyList(source) {\n      // (string[]) -> string[]\n      return source.map(x => x);\n    } // _copyList func.\n    ,\n\n    alterTemplate(step, sourcePlaceholders) {\n      // (step{}, internalTpl.placeholers) -> internalTpl.placeholders\n      // * Rename of placeholders\n      const changes = step.data // { oldPlaceholderName : newPlaceholderName }\n      ,\n            keysPh = Object.keys(sourcePlaceholders),\n            placeholders = {};\n      ;\n      keysPh.forEach(key => {\n        const k = changes[key] || key;\n        placeholders[k] = sourcePlaceholders[key];\n      });\n      return placeholders;\n    } // alterTemplate func.\n    ,\n\n    block(data, space) {\n      //  ( string[] ) -> string[]\n      // * Concatinate strings from array. Returns new array with a single entry\n      return [data.join(space)];\n    } // block func.\n    ,\n\n    set(step, data) {\n      //  ( step{}, string[] ) -> {}[]\n      // * Converts renders and blocks in object\n      const name = step.as,\n            result = data.reduce((res, item) => {\n        let obj = {};\n        obj[name] = item;\n        res.push(obj);\n        return res;\n      }, []);\n      return result;\n    } // set func.\n    ,\n\n    alter(step, data) {\n      // ( step{}, {}[] ) -> {}[]\n      // * Change property names. \n      const changes = step.data,\n            keys = Object.keys(changes),\n            forUpdate = lib._normalizeSelection(step.select, data.length);\n\n      let result = data.map(dataRecord => Object.assign({}, dataRecord));\n      forUpdate.forEach(el => {\n        const selected = result[el];\n        const dataKeys = Object.keys(selected);\n        let update = {};\n        dataKeys.forEach(k => {\n          let value = selected[k];\n          if (keys.includes(k)) k = changes[k];\n          update[k] = value;\n        });\n        result[el] = update;\n      });\n      return result;\n    } // alter func.\n    ,\n\n    _normalizeSelection(list, length) {\n      let result = [];\n\n      if (!list) {\n        result = lib._generateList(length);\n        return result;\n      } // if ( typeof(list) == 'string' ) list = [ list ]\n\n\n      if (typeof list != 'object') list = [list];\n      list.forEach(el => {\n        if (el == 'all') {\n          result = lib._generateList(length);\n          return result;\n        }\n\n        switch (el) {\n          case 'first':\n            result.push(0);\n            break;\n\n          case 'last':\n            result.push(length - 1);\n            break;\n\n          default:\n            if (el < 0) result.push(length - 1 + el);else result.push(el - 1);\n        }\n      });\n      return result;\n    } // _normalizeSelection func.\n    ,\n\n    _generateList(size) {\n      let result = [];\n\n      for (let i = 0; i < size; i++) result.push(i);\n\n      return result;\n    } // _generateList func.\n    ,\n\n    add(step, data) {\n      // ( step{}, {}[] ) -> {}[]\n      // * Add property names\n      const changes = step.data,\n            keys = Object.keys(changes),\n            listForUpdate = lib._normalizeSelection(step.select, data.length);\n\n      let result = data.map(dataRecord => Object.assign({}, dataRecord));\n      listForUpdate.forEach(el => {\n        const selected = result[el];\n        const dataKeys = Object.keys(selected);\n        let update = keys.reduce((res, k) => {\n          if (!selected[k]) res[k] = changes[k];else res[k] = lib._combineValues(selected[k], changes[k]);\n          return res;\n        }, {});\n        result[el] = Object.assign(selected, update);\n      });\n      return result;\n    } // add func.\n    ,\n\n    _combineValues(existing, update) {\n      let primitive = false,\n          result;\n      if (typeof existing != 'object') primitive = true;\n      if (primitive) result = [existing];else result = existing;\n      return result.concat(update).join(' ');\n    } // _combineValues func.\n    ,\n\n    copy(step, data) {\n      //   ( step{}, {}[] ) -> {}[]\n      // * Create new property copy the value.\n      const changes = step.data,\n            keys = Object.keys(changes),\n            forUpdate = lib._normalizeSelection(step.select, data.length),\n            result = data.map(record => Object.assign({}, record));\n\n      forUpdate.forEach(dataRecord => {\n        keys.forEach(k => {\n          const value = result[dataRecord][k];\n          const copyKey = changes[k];\n          result[dataRecord][copyKey] = value;\n        });\n      });\n      return result;\n    } // copy func.\n    ,\n\n    remove(step, data) {\n      // ( step{}, {}[] ) -> {}[]\n      // * Remove existing property\n      const keys = step.keys,\n            forUpdate = lib._normalizeSelection(step.select, data.length),\n            result = data.map(record => Object.assign({}, record));\n\n      forUpdate.forEach(dataRecord => {\n        keys.forEach(k => {\n          delete result[dataRecord][k];\n        });\n      });\n      return result;\n    } // remove func.\n    ,\n\n    hook(data, cb, engine) {\n      // ( {}[], Function ) -> {}[]\n      // * Function placeholder within render process\n      const operation = this; // access to process-tools\n\n      if (!cb) return data;\n      return cb(data, lib.modify(operation, engine)); // 'operation' and 'engine' are dependencies for function 'modify'\n    } // hook func.\n    ,\n\n    _findIfString: list => typeof list[0] == 'string',\n\n    modify(operations, engine) {\n      // ...required dependencies for 'draw'\n      // * Access step-operations inside hook callbacks.\n      return function (data, step) {\n        // ( {}[], step{} ) -> {}[]\n        let act = step.do,\n            dataIsStr = lib._findIfString(data),\n            space = step.space || ' ';\n\n        switch (act) {\n          case 'draw':\n            const template = operations._getTemplate(step.tpl, engine.templates, {}),\n                  sharedData = engine.data,\n                  missField = step.missField,\n                  missData = step.missData,\n                  hookFn = false;\n\n            if (dataIsStr) {\n              console.error(`Hook-modifier require an 'object' data-segment but has a 'string'. {do:'draw', tpl: '${step.tpl}'}`);\n              return data;\n            }\n\n            return lib[act]({\n              template,\n              data,\n              sharedData,\n              missField,\n              missData,\n              hookFn\n            });\n\n          case 'set':\n            if (!dataIsStr) {\n              console.error(`Hook-modifier require a 'string' data-segment but has an 'object'. { do:'${step.do}', as:'${step.as}' }`);\n              return data;\n            }\n\n            return lib[act](step, data);\n\n          case 'block':\n            if (!dataIsStr) {\n              console.error(`Hook-modifier require a 'string' data-segment but have an 'object'. { do:'block' }`);\n              return data;\n            }\n\n            return lib[act](data, space);\n\n          default:\n            if (dataIsStr) {\n              console.error(`Data operations require objects but have strings. Data: ${data}`);\n              return data;\n            }\n\n            return lib[act](step, data);\n        } // switch act\n\n      };\n    } // modify func.\n\n\n  }; // lib\n\n  return lib;\n} // getProcessOperations func.\n\n\nmodule.exports = getProcessOperations;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/process-operations.js?");

/***/ }),

/***/ "./src/process-tools.js":
/*!******************************!*\
  !*** ./src/process-tools.js ***!
  \******************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst validSteps = ['draw', 'alterTemplate', 'alter', 'set', 'add', 'copy', 'remove', 'hook', 'block', 'save'];\n\nfunction getProcessTools({\n  showError,\n  operation\n}) {\n  const lib = {\n    interpret(ext) {\n      //   (ext: extProcess) -> int: intProcess\n      const internal = {};\n      internal.steps = [];\n      internal.arguments = [];\n      internal.hooks = [];\n\n      const errorLog = lib._validate(ext);\n\n      if (errorLog.length > 0) {\n        internal.errors = errorLog;\n        return internal;\n      }\n\n      ext.forEach(step => {\n        internal.steps.push(step.do);\n        internal.arguments.push(step);\n        if (step.do == 'hook') internal.hooks.push(step.name);\n        if (step.hook) internal.hooks.push(step.hook);\n      });\n      return internal;\n    } // interpret func.\n    ,\n\n    _validate(ext) {\n      const log = [],\n            validType = ext instanceof Array;\n      if (!validType) return [showError('wrongExtProcess')];\n      if (ext.length == 0) return [showError('emptyExtProcess')];\n      ext.forEach(step => {\n        let validOperation = false;\n\n        if (!step.do) {\n          log.push(showError('missingOperation'));\n          return;\n        }\n\n        validOperation = validSteps.includes(step.do);\n        if (!validOperation) log.push(showError('notaValidOperation', [step.do]));\n      });\n      return log;\n    } // _validate func.\n    ,\n\n    _findIfString: list => typeof list[0] == 'string',\n\n    _copyList(source) {\n      // (string[]) -> string[]\n      let size = source.length,\n          result = [];\n\n      while (size--) result[size] = source[size];\n\n      return result;\n    } // _copyList func.\n    ,\n\n    _parse(data) {\n      //   (string) -> {} | false\n      try {\n        return JSON.parse(data);\n      } catch (er) {\n        return false;\n      }\n    } // _parse func.\n    ,\n\n    _setupDrawDependencies(me, todo, template, data, hookFn) {\n      // *** Setup 'draw' dependenices\n      const sharedData = me.data,\n            htmlAttributes = me.config.htmlAttributes,\n            missField = todo.missField || false,\n            missData = todo.missData || false;\n      return {\n        template,\n        data,\n        sharedData,\n        htmlAttributes,\n        missField,\n        missData,\n        hookFn\n      };\n    } // _setupDrawDependencies func.\n    ,\n\n    _getTemplate(tplName, library, contextPlaceholders) {\n      // *** Returns a copy of template\n      let template = {},\n          tpl = library[tplName],\n          localPlaceholders = contextPlaceholders[tplName] || library[tplName].placeholders,\n          holderKeys = Object.keys(localPlaceholders);\n      template.tpl = tpl.tpl.map(x => x);\n      template.spaces = Object.assign({}, tpl.spaces);\n      template.placeholders = {};\n      holderKeys.forEach(key => {\n        template.placeholders[key] = localPlaceholders[key].map(x => x);\n      });\n      return template;\n    } // _getTemplate func.\n    ,\n\n    run(proccessItems, data, hooks) {\n      // * Executes process/processes\n      let me = this,\n          libTemplates = me.templates,\n          current = data,\n          currentIsStr = lib._findIfString(current) // current is array of strings or array of objects\n      ,\n          getTemplate = lib._getTemplate // Creates a copy of requested template\n      ,\n          setupDrawDependencies = lib._setupDrawDependencies // Sets draw dependency object\n      ,\n          contextPlaceholders = {};\n\n      proccessItems.steps.forEach((step, id) => {\n        const todo = proccessItems.arguments[id]; //   Get full step instruction\n\n        let tplName,\n            watchHook = todo.watchHook ? hooks[todo.watchHook] || false : false,\n            update = [] // draw result buffer\n        ,\n            space = todo.space != null ? todo.space : ' ',\n            method = todo.method || 'add' // Add method is default\n        // Method possible values: < add | update | heap | overwrite >\n        ;\n\n        switch (step) {\n          case 'draw':\n            tplName = todo.tpl;\n            if (currentIsStr) console.warn(showError('dataExpectObject', `Step \"draw\" with template \"${tplName}\"`));\n            const hookFn = hooks ? hooks[todo.hook] || false : false,\n                  holdData = !(todo.as == null);\n\n            if (watchHook) {\n              current.forEach(dataSegment => {\n                let [watchData, watchTplName] = watchHook(dataSegment, tplName),\n                    watchTemplate = getTemplate(watchTplName, libTemplates, contextPlaceholders),\n                    drawDependencies = {};\n                if (!(watchData instanceof Array)) watchData = [watchData];\n                drawDependencies = setupDrawDependencies(me, todo, watchTemplate, watchData, hookFn);\n                update = update.concat(operation[step](drawDependencies));\n              });\n              update = [update.join(space)];\n            } else {\n              const localTemplate = getTemplate(tplName, libTemplates, contextPlaceholders),\n                    dependenices = setupDrawDependencies(me, todo, localTemplate, current, hookFn);\n              update = operation[step](dependenices);\n            } // else watchHook\n\n\n            if (holdData) {\n              current = current.reduce((res, el, i) => {\n                switch (method) {\n                  case 'add':\n                    // write only if key doesn't exist\n                    if (!el[todo.as]) el[todo.as] = update[i];\n                    break;\n\n                  case 'update':\n                    // overwrite only if key exists\n                    if (el[todo.as]) el[todo.as] = update[i];\n                    break;\n\n                  case 'overwrite':\n                    // always write\n                    el[todo.as] = update[i];\n                    break;\n\n                  case 'heap':\n                    // Add update to the heap. Accumulate value.\n                    el[todo.as] += space + update[i];\n                    break;\n                } // switch method\n\n\n                res.push(el);\n                return res;\n              }, []);\n            } else {\n              current = update;\n              currentIsStr = true;\n            }\n\n            break;\n\n          case 'block':\n            if (!currentIsStr) {\n              console.error(showError('blockExpectString', JSON.stringify(current)));\n              return;\n            }\n\n            const blockSpace = todo.space || '';\n            current = operation[step](current, blockSpace);\n\n            if (todo.name) {\n              let newData = {};\n              newData[`block/${todo.name}`] = current.join('');\n              me.insertData(newData, method);\n            }\n\n            break;\n\n          case 'add':\n            current = operation[step](todo, current);\n            break;\n\n          case 'alterTemplate':\n            tplName = todo.tpl;\n            const intTemplate = libTemplates[tplName];\n            contextPlaceholders[tplName] = operation[step](todo, intTemplate.placeholders);\n            break;\n\n          case 'set':\n            current = operation[step](todo, current);\n            currentIsStr = false;\n            break;\n\n          case 'hook':\n            let extend = todo.as || false,\n                hooked = [] // storage for hook results\n            ;\n            current.forEach(dataSegment => {\n              const dt = [dataSegment];\n              hooked.push(operation[step].call(lib, dt, hooks[todo.name], me)[0]);\n            });\n\n            if (extend) {\n              current = current.map((dataSegment, i) => {\n                const hk = hooked[i],\n                      res = hk instanceof Array ? hk.join(space) : hk;\n\n                switch (method) {\n                  case 'add':\n                    // write only if key doesn't exist\n                    if (!dataSegment[extend]) dataSegment[extend] = res;\n                    break;\n\n                  case 'update':\n                    // overwrite only if key exists\n                    if (dataSegment[extend]) dataSegment[extend] = res;\n                    break;\n\n                  case 'overwrite':\n                    // always write\n                    dataSegment[extend] = res;\n                    break;\n\n                  case 'heap':\n                    // Add update to the heap. Accumulate value.\n                    dataSegment[extend] += space + res;\n                    break;\n                } // switch method\n\n\n                return dataSegment;\n              });\n              break;\n            }\n\n            current = hooked.reduce((acc, item) => {\n              const isArray = item instanceof Array,\n                    isStr = lib._findIfString(item);\n\n              if (isArray && isStr) {\n                // Array of strings\n                item = item.join(space);\n                acc.push(item);\n                return acc;\n              }\n\n              if (isArray) {\n                // Array of objects\n                acc = acc.concat(item);\n                return acc;\n              }\n\n              acc.push(item);\n              return acc;\n            }, []);\n            currentIsStr = lib._findIfString(current);\n            break;\n\n          case 'save':\n            const saveName = todo.as != 'block' ? todo.name : `block/${todo.name}`;\n            let currentData = {};\n\n            switch (todo.as) {\n              case 'block':\n              case 'data':\n                if (!currentIsStr) {\n                  console.log(showError('blockExpectString', JSON.stringify(current)));\n                  break;\n                }\n\n                currentData[saveName] = current.join('');\n                me.insertData(currentData, method);\n                break;\n\n              case 'template':\n                currentData[saveName] = current[0];\n                me.insertTemplate(currentData, method);\n                break;\n\n              case 'process':\n                let newProcess = lib._parse(current[0]);\n\n                if (newProcess) me.insertProcess(newProcess, saveName);else console.error(showError('invalidJSON', current[0]));\n                break;\n\n              default:\n                console.error(showError('invalidStorageName', todo.as));\n                return;\n            }\n\n            break;\n        } // switch step\n\n      }); // forEach step\n\n      return current;\n    } // run func.\n\n\n  }; // lib\n\n  return lib;\n} // getProcessTools func.\n\n\nmodule.exports = getProcessTools;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/process-tools.js?");

/***/ }),

/***/ "./src/template-chop.js":
/*!******************************!*\
  !*** ./src/template-chop.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst showError = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/*\n     Converts string template to internal template format\n     ( text: string ) -> string[]\n\n*/\n\n\nfunction chopTemplate(text) {\n  let start // placeholder start\n  ,\n      end // placeholder end\n  ,\n      checkPoint // check \n  ,\n      res = [] // template result array\n  ;\n  if (typeof text != 'string') return [showError('brokenTemplate')];\n  if (text.length == 0) return [];\n  start = text.indexOf('{{');\n  if (0 < start) res.push(text.slice(0, start));\n\n  if (-1 == start) {\n    res.push(text);\n    return res;\n  } else {\n    checkPoint = text.indexOf('{{', start + 2);\n    end = text.indexOf(\"}}\");\n    if (end == -1) return [showError('brokenTemplate')]; // Placeholder with missing closing tags\n\n    if (end < start) return [showError('brokenTemplate')]; // Placeholder closing tags without starting ones\n    else end += 2;\n\n    if (checkPoint != -1 && checkPoint < end) {\n      // New placeholder before first ends\n      return [showError('brokenTemplate')];\n    }\n\n    res.push(text.slice(start, end));\n    let nextText = text.slice(end);\n    let additional = chopTemplate(nextText);\n    return res.concat(additional);\n  }\n} // chopTemplate func.\n\n\nmodule.exports = chopTemplate;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/template-chop.js?");

/***/ }),

/***/ "./src/template-tools.js":
/*!*******************************!*\
  !*** ./src/template-tools.js ***!
  \*******************************/
/***/ ((module) => {

"use strict";
eval("\n/*\n    Converts ExtTempalteString to InternalTpl.\n\n     Import string template\n      ( stringTemplate: string ) -> internalTemplate\n       internalTemplate: { tpl: tplData, placeholders?:indexOfPlaceholders, error?: errorMsg }\n       indexOfPlaceholders: { placeholderName: indexInTplData }\n       errorMsg: string  \n      \n      tplData: string[]; Contains text and placeholders.\n      Example:\n          [\n              'Some words from '         //text\n            , '{{person}}'               // placeholder\n            , ' - See how simple is it'  //text\n          ]\n      \n      placeholderName is extracted value of placeholder.\n      Example:\n          placeholder: {{person}}\n          placeholderName: person    \n*/\n\nfunction getTemplateTools({\n  chop,\n  showError\n}) {\n  const lib = {\n    str2intTemplate(str) {\n      const r = chop(str);\n      const error = r.includes(showError('brokenTemplate'));\n      let placeholders = {},\n          spaces = {} // { placeholderName: spaceType } \n      ;\n      /*\n          placeholderName: string. Name of the placeholder.\n          spaceType:enum. \n                  1-space before, \n                  2-space after, \n                  3-both spaces\n      */\n\n      if (!error) {\n        const t = lib._findPlaceholdersAndSpaces(r);\n\n        spaces = t.spaces;\n        placeholders = t.placeholders;\n      }\n\n      const template = {\n        tpl: r,\n        placeholders,\n        spaces\n      };\n      if (error) template.errors = [showError('brokenTemplate')];\n      return template;\n    } // str2inTemplate func.\n    ,\n\n    load_interpretTemplate(convert2intTemplate) {\n      return tplItem => {\n        let intTemplate = {}; // internal template\n\n        const type = typeof tplItem == 'string' ? 'string' : 'error';\n        if (type == 'string') intTemplate = convert2intTemplate(tplItem);else intTemplate = {\n          errors: [showError('wrongDataTemplate')]\n        };\n        return intTemplate;\n      };\n    } // load_interpretTemplate func.\n    ,\n\n    _findPlaceholdersAndSpaces(tplArray) {\n      const placeholders = {},\n            spaces = {};\n      tplArray.forEach((item, i) => {\n        if (item.slice(0, 2) == '{{') {\n          let start = 2,\n              end = -2;\n          const before = item.slice(2, 4) == '~~';\n          const after = item.slice(-4, -2) == '~~';\n          if (before) start = 4;\n          if (after) end = -4;\n          const phName = item.slice(start, end);\n          if (before && after) spaces[phName] = 3; // before and after\n          else if (after) spaces[phName] = 2; // only after\n            else if (before) spaces[phName] = 1; // only before\n\n          if (placeholders.hasOwnProperty(phName)) placeholders[phName].push(i);else placeholders[phName] = [i];\n        }\n      });\n      return {\n        spaces,\n        placeholders\n      };\n    } // findPlaceholders func.\n\n\n  }; // lib\n\n  return lib;\n} // getTemplateTools func.\n\n\nmodule.exports = getTemplateTools;\n\n//# sourceURL=webpack://CodeAssemblyLine/./src/template-tools.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	CodeAssemblyLine = __webpack_exports__;
/******/ 	
/******/ })()
;